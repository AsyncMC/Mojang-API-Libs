// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Mojang API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: 2020-06-05
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "https://api.mojang.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *  
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * The current player, demo and legacy status of a player identified by the id
 * @export
 * @interface CurrentPlayerIDs
 */
export interface CurrentPlayerIDs {
    /**
     * The player UUID without hyphens
     * @type {string}
     * @memberof CurrentPlayerIDs
     */
    id: string;
    /**
     * The current name being used by this player
     * @type {string}
     * @memberof CurrentPlayerIDs
     */
    name: string;
    /**
     * If account has not been converted
     * @type {boolean}
     * @memberof CurrentPlayerIDs
     */
    legacy?: boolean;
    /**
     * If the player has not puchased the game
     * @type {boolean}
     * @memberof CurrentPlayerIDs
     */
    demo?: boolean;
}

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {SkinModel}
     * @memberof InlineObject
     */
    model?: SkinModel;
    /**
     * The skin image in PNG format
     * @type {any}
     * @memberof InlineObject
     */
    file: any;
}

/**
 * Request Mojang to download a skin from an URL and apply to the player
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {SkinModel}
     * @memberof InlineObject1
     */
    model?: SkinModel;
    /**
     * The URL which Mojang servers will download and apply the skin
     * @type {string}
     * @memberof InlineObject1
     */
    url: string;
}

/**
 * This is returned when the request fails
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    errorMessage?: string;
}

/**
 * A registered name change.
 * @export
 * @interface NameChange
 */
export interface NameChange {
    /**
     * The new player name
     * @type {string}
     * @memberof NameChange
     */
    name: string;
    /**
     * Time which the name was changed in UNIX Timestamp without milliseconds. Usually absent for the first entry.
     * @type {number}
     * @memberof NameChange
     */
    changedToAt?: number;
}

/**
 * Valid options to query the order statistics
 * @export
 * @enum {string}
 */
export enum OrderStatistic {
    ItemSoldMinecraft = 'item_sold_minecraft',
    PrepaidCardRedeemedMinecraft = 'prepaid_card_redeemed_minecraft',
    ItemSoldCobalt = 'item_sold_cobalt',
    ItemSoldScrolls = 'item_sold_scrolls',
    PrepaidCardRedeemedCobalt = 'prepaid_card_redeemed_cobalt',
    ItemSoldDungeons = 'item_sold_dungeons'
}

/**
 * The body of the request to get the order statistics
 * @export
 * @interface OrderStatisticsRequest
 */
export interface OrderStatisticsRequest {
    /**
     * 
     * @type {Array<OrderStatistic>}
     * @memberof OrderStatisticsRequest
     */
    metricKeys: Array<OrderStatistic>;
}

/**
 * A json object is returned with the total amount of copies sold, the amount of copies sold in the last 24h and how many sales there are per second.
 * @export
 * @interface OrderStatisticsResponse
 */
export interface OrderStatisticsResponse {
    /**
     * total amount sold
     * @type {number}
     * @memberof OrderStatisticsResponse
     */
    total: number;
    /**
     * total sold in last 24 hours
     * @type {number}
     * @memberof OrderStatisticsResponse
     */
    last24h: number;
    /**
     * decimal average sales per second
     * @type {number}
     * @memberof OrderStatisticsResponse
     */
    saleVelocityPerSeconds: number;
}

/**
 * A security question answer given by the player using the id given by Mojang
 * @export
 * @interface SecurityAnswer
 */
export interface SecurityAnswer extends SecurityAnswerId {
}

/**
 * A security question answer id given by Mojang
 * @export
 * @interface SecurityAnswerId
 */
export interface SecurityAnswerId {
    /**
     * A number giver by Mojang to reply a question
     * @type {number}
     * @memberof SecurityAnswerId
     */
    id: number;
}

/**
 * Binds a question to an answer id, the answer must respect the answer id.
 * @export
 * @interface SecurityChallenge
 */
export interface SecurityChallenge {
    /**
     * 
     * @type {SecurityQuestion}
     * @memberof SecurityChallenge
     */
    question: SecurityQuestion;
    /**
     * 
     * @type {SecurityAnswerId}
     * @memberof SecurityChallenge
     */
    answer: SecurityAnswerId;
}

/**
 * A security question requested by Mojang
 * @export
 * @interface SecurityQuestion
 */
export interface SecurityQuestion {
    /**
     * The possible IDs are these:   1  What is your favorite pet's name?   2  What is your favorite movie?   3  What is your favorite author's last name?   4  What is your favorite artist's last name?   5  What is your favorite actor's last name?   6  What is your favorite activity?   7  What is your favorite restaurant?   8  What is the name of your favorite cartoon?   9  What is the name of the first school you attended?   10 What is the last name of your favorite teacher?   11 What is your best friend's first name?   12 What is your favorite cousin's name?   13 What was the first name of your first girl/boyfriend?   14 What was the name of your first stuffed animal?   15 What is your mother's middle name?   16 What is your father's middle name?   17 What is your oldest sibling's middle name?   18 In what city did your parents meet?   19 In what hospital were you born?   20 What is your favorite team?   21 How old were you when you got your first computer?   22 How old were you when you got your first gaming console?   23 What was your first video game?   24 What is your favorite card game?   25 What is your favorite board game?   26 What was your first gaming console?   27 What was the first book you ever read?   28 Where did you go on your first holiday?   29 In what city does your grandmother live?   30 In what city does your grandfather live?   31 What is your grandmother's first name?   32 What is your grandfather's first name?   33 What is your least favorite food?   34 What is your favorite ice cream flavor?   35 What is your favorite ice cream flavor?   36 What is your favorite place to visit?   37 What is your dream job?   38 What color was your first pet?   39 What is your lucky number?
     * @type {number}
     * @memberof SecurityQuestion
     */
    id: number;
    /**
     * The question itself
     * @type {string}
     * @memberof SecurityQuestion
     */
    question: string;
}

/**
 * Model is an empty string for the default model (like Steve) and \"slim\" for the slim model (like Alex)
 * @export
 * @enum {string}
 */
export enum SkinModel {
    Empty = '',
    Slim = 'slim'
}


/**
 * MiscellaneousApi - axios parameter creator
 * @export
 */
export const MiscellaneousApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get statistics on the sales of Minecraft.
         * @param {OrderStatisticsRequest} orderStatisticsRequest The payload is a json list of options under the metricKeys key. You will receive a single object corresponding to the sum of sales of the requested type(s). You must request at least one type of sale. Below is the default list used by https://minecraft.net/en/stats/
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersStatistics(orderStatisticsRequest: OrderStatisticsRequest, options: any = {}): RequestArgs {
            // verify required parameter 'orderStatisticsRequest' is not null or undefined
            if (orderStatisticsRequest === null || orderStatisticsRequest === undefined) {
                throw new RequiredError('orderStatisticsRequest','Required parameter orderStatisticsRequest was null or undefined when calling getOrdersStatistics.');
            }
            const localVarPath = `/orders/statistics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication MojangStatisticsToken required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderStatisticsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(orderStatisticsRequest || {}) : (orderStatisticsRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscellaneousApi - functional programming interface
 * @export
 */
export const MiscellaneousApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get statistics on the sales of Minecraft.
         * @param {OrderStatisticsRequest} orderStatisticsRequest The payload is a json list of options under the metricKeys key. You will receive a single object corresponding to the sum of sales of the requested type(s). You must request at least one type of sale. Below is the default list used by https://minecraft.net/en/stats/
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersStatistics(orderStatisticsRequest: OrderStatisticsRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderStatisticsResponse> {
            const localVarAxiosArgs = MiscellaneousApiAxiosParamCreator(configuration).getOrdersStatistics(orderStatisticsRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * MiscellaneousApi - factory interface
 * @export
 */
export const MiscellaneousApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get statistics on the sales of Minecraft.
         * @param {OrderStatisticsRequest} orderStatisticsRequest The payload is a json list of options under the metricKeys key. You will receive a single object corresponding to the sum of sales of the requested type(s). You must request at least one type of sale. Below is the default list used by https://minecraft.net/en/stats/
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersStatistics(orderStatisticsRequest: OrderStatisticsRequest, options?: any) {
            return MiscellaneousApiFp(configuration).getOrdersStatistics(orderStatisticsRequest, options)(axios, basePath);
        },
    };
};

/**
 * MiscellaneousApi - object-oriented interface
 * @export
 * @class MiscellaneousApi
 * @extends {BaseAPI}
 */
export class MiscellaneousApi extends BaseAPI {
    /**
     * 
     * @summary Get statistics on the sales of Minecraft.
     * @param {OrderStatisticsRequest} orderStatisticsRequest The payload is a json list of options under the metricKeys key. You will receive a single object corresponding to the sum of sales of the requested type(s). You must request at least one type of sale. Below is the default list used by https://minecraft.net/en/stats/
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getOrdersStatistics(orderStatisticsRequest: OrderStatisticsRequest, options?: any) {
        return MiscellaneousApiFp(this.configuration).getOrdersStatistics(orderStatisticsRequest, options)(this.axios, this.basePath);
    }

}

/**
 * NameHistoryApi - axios parameter creator
 * @export
 */
export const NameHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find the current players name, UUID, demo status and migration flag by the current players name. The \"at\" parameter is not supported. Players not found are not returned. If no players are found, an empty array is returned.
         * @summary Find the current UUID of multiple players at once
         * @param {Array<string>} requestBody Array with the player names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUniqueIdsByName(requestBody: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling findUniqueIdsByName.');
            }
            const localVarPath = `/profiles/minecraft`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the full player's name history
         * @param {string} strippedUuid The player UUID without hyphens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNameHistory(strippedUuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'strippedUuid' is not null or undefined
            if (strippedUuid === null || strippedUuid === undefined) {
                throw new RequiredError('strippedUuid','Required parameter strippedUuid was null or undefined when calling getNameHistory.');
            }
            const localVarPath = `/user/profiles/{stripped_uuid}/names`
                .replace(`{${"stripped_uuid"}}`, encodeURIComponent(String(strippedUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find the current player name, UUID, demo status and migration flag by the current player name or at a given time.
         * @summary Find the UUID by name
         * @param {string} username The username in a given time, or in present if \&quot;at\&quot; is not sent
         * @param {number} [at] Find the username in a given time, when 0 selects the original name however, it only works if the name was changed at least once, or if the account is legacy. The time is an UNIX timestamp (without milliseconds)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniqueIdByName(username: string, at?: number, options: any = {}): RequestArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling getUniqueIdByName.');
            }
            const localVarPath = `/users/profiles/minecraft/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (at !== undefined) {
                localVarQueryParameter['at'] = at;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NameHistoryApi - functional programming interface
 * @export
 */
export const NameHistoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Find the current players name, UUID, demo status and migration flag by the current players name. The \"at\" parameter is not supported. Players not found are not returned. If no players are found, an empty array is returned.
         * @summary Find the current UUID of multiple players at once
         * @param {Array<string>} requestBody Array with the player names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUniqueIdsByName(requestBody: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CurrentPlayerIDs>> {
            const localVarAxiosArgs = NameHistoryApiAxiosParamCreator(configuration).findUniqueIdsByName(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Gets the full player's name history
         * @param {string} strippedUuid The player UUID without hyphens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNameHistory(strippedUuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameChange>> {
            const localVarAxiosArgs = NameHistoryApiAxiosParamCreator(configuration).getNameHistory(strippedUuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Find the current player name, UUID, demo status and migration flag by the current player name or at a given time.
         * @summary Find the UUID by name
         * @param {string} username The username in a given time, or in present if \&quot;at\&quot; is not sent
         * @param {number} [at] Find the username in a given time, when 0 selects the original name however, it only works if the name was changed at least once, or if the account is legacy. The time is an UNIX timestamp (without milliseconds)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniqueIdByName(username: string, at?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentPlayerIDs> {
            const localVarAxiosArgs = NameHistoryApiAxiosParamCreator(configuration).getUniqueIdByName(username, at, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * NameHistoryApi - factory interface
 * @export
 */
export const NameHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Find the current players name, UUID, demo status and migration flag by the current players name. The \"at\" parameter is not supported. Players not found are not returned. If no players are found, an empty array is returned.
         * @summary Find the current UUID of multiple players at once
         * @param {Array<string>} requestBody Array with the player names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUniqueIdsByName(requestBody: Array<string>, options?: any) {
            return NameHistoryApiFp(configuration).findUniqueIdsByName(requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @summary Gets the full player's name history
         * @param {string} strippedUuid The player UUID without hyphens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNameHistory(strippedUuid: string, options?: any) {
            return NameHistoryApiFp(configuration).getNameHistory(strippedUuid, options)(axios, basePath);
        },
        /**
         * Find the current player name, UUID, demo status and migration flag by the current player name or at a given time.
         * @summary Find the UUID by name
         * @param {string} username The username in a given time, or in present if \&quot;at\&quot; is not sent
         * @param {number} [at] Find the username in a given time, when 0 selects the original name however, it only works if the name was changed at least once, or if the account is legacy. The time is an UNIX timestamp (without milliseconds)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniqueIdByName(username: string, at?: number, options?: any) {
            return NameHistoryApiFp(configuration).getUniqueIdByName(username, at, options)(axios, basePath);
        },
    };
};

/**
 * NameHistoryApi - object-oriented interface
 * @export
 * @class NameHistoryApi
 * @extends {BaseAPI}
 */
export class NameHistoryApi extends BaseAPI {
    /**
     * Find the current players name, UUID, demo status and migration flag by the current players name. The \"at\" parameter is not supported. Players not found are not returned. If no players are found, an empty array is returned.
     * @summary Find the current UUID of multiple players at once
     * @param {Array<string>} requestBody Array with the player names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NameHistoryApi
     */
    public findUniqueIdsByName(requestBody: Array<string>, options?: any) {
        return NameHistoryApiFp(this.configuration).findUniqueIdsByName(requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Gets the full player's name history
     * @param {string} strippedUuid The player UUID without hyphens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NameHistoryApi
     */
    public getNameHistory(strippedUuid: string, options?: any) {
        return NameHistoryApiFp(this.configuration).getNameHistory(strippedUuid, options)(this.axios, this.basePath);
    }

    /**
     * Find the current player name, UUID, demo status and migration flag by the current player name or at a given time.
     * @summary Find the UUID by name
     * @param {string} username The username in a given time, or in present if \&quot;at\&quot; is not sent
     * @param {number} [at] Find the username in a given time, when 0 selects the original name however, it only works if the name was changed at least once, or if the account is legacy. The time is an UNIX timestamp (without milliseconds)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NameHistoryApi
     */
    public getUniqueIdByName(username: string, at?: number, options?: any) {
        return NameHistoryApiFp(this.configuration).getUniqueIdByName(username, at, options)(this.axios, this.basePath);
    }

}

/**
 * SecurityQuestionAnswerApi - axios parameter creator
 * @export
 */
export const SecurityQuestionAnswerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check if security questions are needed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSecurityStatus(options: any = {}): RequestArgs {
            const localVarPath = `/user/security/location`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PlayerAccessToken required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPendingSecurityQuestions(options: any = {}): RequestArgs {
            const localVarPath = `/user/security/challenges`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PlayerAccessToken required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send back the answers
         * @param {Array<SecurityAnswer>} securityAnswer An array with all the answers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSecurityQuestionAnswers(securityAnswer: Array<SecurityAnswer>, options: any = {}): RequestArgs {
            // verify required parameter 'securityAnswer' is not null or undefined
            if (securityAnswer === null || securityAnswer === undefined) {
                throw new RequiredError('securityAnswer','Required parameter securityAnswer was null or undefined when calling sendSecurityQuestionAnswers.');
            }
            const localVarPath = `/user/security/location`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PlayerAccessToken required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;SecurityAnswer&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(securityAnswer || {}) : (securityAnswer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityQuestionAnswerApi - functional programming interface
 * @export
 */
export const SecurityQuestionAnswerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check if security questions are needed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSecurityStatus(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = SecurityQuestionAnswerApiAxiosParamCreator(configuration).checkSecurityStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get list of questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPendingSecurityQuestions(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SecurityChallenge>> {
            const localVarAxiosArgs = SecurityQuestionAnswerApiAxiosParamCreator(configuration).listPendingSecurityQuestions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Send back the answers
         * @param {Array<SecurityAnswer>} securityAnswer An array with all the answers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSecurityQuestionAnswers(securityAnswer: Array<SecurityAnswer>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = SecurityQuestionAnswerApiAxiosParamCreator(configuration).sendSecurityQuestionAnswers(securityAnswer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * SecurityQuestionAnswerApi - factory interface
 * @export
 */
export const SecurityQuestionAnswerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Check if security questions are needed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSecurityStatus(options?: any) {
            return SecurityQuestionAnswerApiFp(configuration).checkSecurityStatus(options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPendingSecurityQuestions(options?: any) {
            return SecurityQuestionAnswerApiFp(configuration).listPendingSecurityQuestions(options)(axios, basePath);
        },
        /**
         * 
         * @summary Send back the answers
         * @param {Array<SecurityAnswer>} securityAnswer An array with all the answers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSecurityQuestionAnswers(securityAnswer: Array<SecurityAnswer>, options?: any) {
            return SecurityQuestionAnswerApiFp(configuration).sendSecurityQuestionAnswers(securityAnswer, options)(axios, basePath);
        },
    };
};

/**
 * SecurityQuestionAnswerApi - object-oriented interface
 * @export
 * @class SecurityQuestionAnswerApi
 * @extends {BaseAPI}
 */
export class SecurityQuestionAnswerApi extends BaseAPI {
    /**
     * 
     * @summary Check if security questions are needed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityQuestionAnswerApi
     */
    public checkSecurityStatus(options?: any) {
        return SecurityQuestionAnswerApiFp(this.configuration).checkSecurityStatus(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of questions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityQuestionAnswerApi
     */
    public listPendingSecurityQuestions(options?: any) {
        return SecurityQuestionAnswerApiFp(this.configuration).listPendingSecurityQuestions(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Send back the answers
     * @param {Array<SecurityAnswer>} securityAnswer An array with all the answers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityQuestionAnswerApi
     */
    public sendSecurityQuestionAnswers(securityAnswer: Array<SecurityAnswer>, options?: any) {
        return SecurityQuestionAnswerApiFp(this.configuration).sendSecurityQuestionAnswers(securityAnswer, options)(this.axios, this.basePath);
    }

}

/**
 * SkinOperationsApi - axios parameter creator
 * @export
 */
export const SkinOperationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will set the skin for the selected profile, but Mojang's servers will fetch the skin from a URL. This will also work for legacy accounts.
         * @summary Changes the player skin by URL
         * @param {string} strippedUuid The player UUID without hyphens
         * @param {string} url The URL which Mojang servers will download and apply the skin
         * @param {SkinModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePlayerSkin(strippedUuid: string, url: string, model?: SkinModel, options: any = {}): RequestArgs {
            // verify required parameter 'strippedUuid' is not null or undefined
            if (strippedUuid === null || strippedUuid === undefined) {
                throw new RequiredError('strippedUuid','Required parameter strippedUuid was null or undefined when calling changePlayerSkin.');
            }
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new RequiredError('url','Required parameter url was null or undefined when calling changePlayerSkin.');
            }
            const localVarPath = `/user/profile/{stripped_uuid}/skin`
                .replace(`{${"stripped_uuid"}}`, encodeURIComponent(String(strippedUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication PlayerAccessToken required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (model !== undefined) {
                localVarFormParams.set('model', model as any);
            }

            if (url !== undefined) {
                localVarFormParams.set('url', url as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resets the player skin to default
         * @param {string} strippedUuid The player UUID without hyphens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPlayerSkin(strippedUuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'strippedUuid' is not null or undefined
            if (strippedUuid === null || strippedUuid === undefined) {
                throw new RequiredError('strippedUuid','Required parameter strippedUuid was null or undefined when calling resetPlayerSkin.');
            }
            const localVarPath = `/user/profile/{stripped_uuid}/skin`
                .replace(`{${"stripped_uuid"}}`, encodeURIComponent(String(strippedUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PlayerAccessToken required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This uploads a skin to Mojang's servers. It also sets the users skin. This works on legacy counts as well.
         * @summary Changes the player skin by upload
         * @param {string} strippedUuid The player UUID without hyphens
         * @param {any} file The skin image in PNG format
         * @param {SkinModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPlayerSkin(strippedUuid: string, file: any, model?: SkinModel, options: any = {}): RequestArgs {
            // verify required parameter 'strippedUuid' is not null or undefined
            if (strippedUuid === null || strippedUuid === undefined) {
                throw new RequiredError('strippedUuid','Required parameter strippedUuid was null or undefined when calling uploadPlayerSkin.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling uploadPlayerSkin.');
            }
            const localVarPath = `/user/profile/{stripped_uuid}/skin`
                .replace(`{${"stripped_uuid"}}`, encodeURIComponent(String(strippedUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication PlayerAccessToken required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (model !== undefined) {
                localVarFormParams.set('model', model as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SkinOperationsApi - functional programming interface
 * @export
 */
export const SkinOperationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This will set the skin for the selected profile, but Mojang's servers will fetch the skin from a URL. This will also work for legacy accounts.
         * @summary Changes the player skin by URL
         * @param {string} strippedUuid The player UUID without hyphens
         * @param {string} url The URL which Mojang servers will download and apply the skin
         * @param {SkinModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePlayerSkin(strippedUuid: string, url: string, model?: SkinModel, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = SkinOperationsApiAxiosParamCreator(configuration).changePlayerSkin(strippedUuid, url, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Resets the player skin to default
         * @param {string} strippedUuid The player UUID without hyphens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPlayerSkin(strippedUuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = SkinOperationsApiAxiosParamCreator(configuration).resetPlayerSkin(strippedUuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * This uploads a skin to Mojang's servers. It also sets the users skin. This works on legacy counts as well.
         * @summary Changes the player skin by upload
         * @param {string} strippedUuid The player UUID without hyphens
         * @param {any} file The skin image in PNG format
         * @param {SkinModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPlayerSkin(strippedUuid: string, file: any, model?: SkinModel, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = SkinOperationsApiAxiosParamCreator(configuration).uploadPlayerSkin(strippedUuid, file, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * SkinOperationsApi - factory interface
 * @export
 */
export const SkinOperationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This will set the skin for the selected profile, but Mojang's servers will fetch the skin from a URL. This will also work for legacy accounts.
         * @summary Changes the player skin by URL
         * @param {string} strippedUuid The player UUID without hyphens
         * @param {string} url The URL which Mojang servers will download and apply the skin
         * @param {SkinModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePlayerSkin(strippedUuid: string, url: string, model?: SkinModel, options?: any) {
            return SkinOperationsApiFp(configuration).changePlayerSkin(strippedUuid, url, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Resets the player skin to default
         * @param {string} strippedUuid The player UUID without hyphens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPlayerSkin(strippedUuid: string, options?: any) {
            return SkinOperationsApiFp(configuration).resetPlayerSkin(strippedUuid, options)(axios, basePath);
        },
        /**
         * This uploads a skin to Mojang's servers. It also sets the users skin. This works on legacy counts as well.
         * @summary Changes the player skin by upload
         * @param {string} strippedUuid The player UUID without hyphens
         * @param {any} file The skin image in PNG format
         * @param {SkinModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPlayerSkin(strippedUuid: string, file: any, model?: SkinModel, options?: any) {
            return SkinOperationsApiFp(configuration).uploadPlayerSkin(strippedUuid, file, model, options)(axios, basePath);
        },
    };
};

/**
 * SkinOperationsApi - object-oriented interface
 * @export
 * @class SkinOperationsApi
 * @extends {BaseAPI}
 */
export class SkinOperationsApi extends BaseAPI {
    /**
     * This will set the skin for the selected profile, but Mojang's servers will fetch the skin from a URL. This will also work for legacy accounts.
     * @summary Changes the player skin by URL
     * @param {string} strippedUuid The player UUID without hyphens
     * @param {string} url The URL which Mojang servers will download and apply the skin
     * @param {SkinModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkinOperationsApi
     */
    public changePlayerSkin(strippedUuid: string, url: string, model?: SkinModel, options?: any) {
        return SkinOperationsApiFp(this.configuration).changePlayerSkin(strippedUuid, url, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Resets the player skin to default
     * @param {string} strippedUuid The player UUID without hyphens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkinOperationsApi
     */
    public resetPlayerSkin(strippedUuid: string, options?: any) {
        return SkinOperationsApiFp(this.configuration).resetPlayerSkin(strippedUuid, options)(this.axios, this.basePath);
    }

    /**
     * This uploads a skin to Mojang's servers. It also sets the users skin. This works on legacy counts as well.
     * @summary Changes the player skin by upload
     * @param {string} strippedUuid The player UUID without hyphens
     * @param {any} file The skin image in PNG format
     * @param {SkinModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkinOperationsApi
     */
    public uploadPlayerSkin(strippedUuid: string, file: any, model?: SkinModel, options?: any) {
        return SkinOperationsApiFp(this.configuration).uploadPlayerSkin(strippedUuid, file, model, options)(this.axios, this.basePath);
    }

}

