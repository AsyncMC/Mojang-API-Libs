{-
   Mojang Authentication API

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.1
   Mojang Authentication API API version: 2020-06-05
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : MojangAuthentication.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module MojangAuthentication.Model where

import MojangAuthentication.Core
import MojangAuthentication.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- * Models


-- ** AccessKeys
-- | AccessKeys
data AccessKeys = AccessKeys
  { accessKeysAccessToken :: !(Text) -- ^ /Required/ "accessToken"
  , accessKeysClientToken :: !(Maybe Text) -- ^ "clientToken"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccessKeys
instance A.FromJSON AccessKeys where
  parseJSON = A.withObject "AccessKeys" $ \o ->
    AccessKeys
      <$> (o .:  "accessToken")
      <*> (o .:? "clientToken")

-- | ToJSON AccessKeys
instance A.ToJSON AccessKeys where
  toJSON AccessKeys {..} =
   _omitNulls
      [ "accessToken" .= accessKeysAccessToken
      , "clientToken" .= accessKeysClientToken
      ]


-- | Construct a value of type 'AccessKeys' (by applying it's required fields, if any)
mkAccessKeys
  :: Text -- ^ 'accessKeysAccessToken' 
  -> AccessKeys
mkAccessKeys accessKeysAccessToken =
  AccessKeys
  { accessKeysAccessToken
  , accessKeysClientToken = Nothing
  }

-- ** Agent
-- | Agent
-- Identifies the software doing the request
data Agent = Agent
  { agentName :: !(Maybe E'Name) -- ^ "name" - The name of the game
  , agentVersion :: !(Maybe Int) -- ^ "version" - The agent version, usually 1.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Agent
instance A.FromJSON Agent where
  parseJSON = A.withObject "Agent" $ \o ->
    Agent
      <$> (o .:? "name")
      <*> (o .:? "version")

-- | ToJSON Agent
instance A.ToJSON Agent where
  toJSON Agent {..} =
   _omitNulls
      [ "name" .= agentName
      , "version" .= agentVersion
      ]


-- | Construct a value of type 'Agent' (by applying it's required fields, if any)
mkAgent
  :: Agent
mkAgent =
  Agent
  { agentName = Nothing
  , agentVersion = Nothing
  }

-- ** Authentication
-- | Authentication
data Authentication = Authentication
  { authenticationAccessToken :: !(Text) -- ^ /Required/ "accessToken"
  , authenticationClientToken :: !(Maybe Text) -- ^ "clientToken"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Authentication
instance A.FromJSON Authentication where
  parseJSON = A.withObject "Authentication" $ \o ->
    Authentication
      <$> (o .:  "accessToken")
      <*> (o .:? "clientToken")

-- | ToJSON Authentication
instance A.ToJSON Authentication where
  toJSON Authentication {..} =
   _omitNulls
      [ "accessToken" .= authenticationAccessToken
      , "clientToken" .= authenticationClientToken
      ]


-- | Construct a value of type 'Authentication' (by applying it's required fields, if any)
mkAuthentication
  :: Text -- ^ 'authenticationAccessToken' 
  -> Authentication
mkAuthentication authenticationAccessToken =
  Authentication
  { authenticationAccessToken
  , authenticationClientToken = Nothing
  }

-- ** AuthenticationRequest
-- | AuthenticationRequest
-- Request body needed to authenticate the player using the username/e-mail and password. Use with care. This is a risky operation.
data AuthenticationRequest = AuthenticationRequest
  { authenticationRequestUsername :: !(Text) -- ^ /Required/ "username" - The Mojang account e-mail or username. Never store it.
  , authenticationRequestPassword :: !(Text) -- ^ /Required/ "password" - The Mojang account password, never store it.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthenticationRequest
instance A.FromJSON AuthenticationRequest where
  parseJSON = A.withObject "AuthenticationRequest" $ \o ->
    AuthenticationRequest
      <$> (o .:  "username")
      <*> (o .:  "password")

-- | ToJSON AuthenticationRequest
instance A.ToJSON AuthenticationRequest where
  toJSON AuthenticationRequest {..} =
   _omitNulls
      [ "username" .= authenticationRequestUsername
      , "password" .= authenticationRequestPassword
      ]


-- | Construct a value of type 'AuthenticationRequest' (by applying it's required fields, if any)
mkAuthenticationRequest
  :: Text -- ^ 'authenticationRequestUsername': The Mojang account e-mail or username. Never store it.
  -> Text -- ^ 'authenticationRequestPassword': The Mojang account password, never store it.
  -> AuthenticationRequest
mkAuthenticationRequest authenticationRequestUsername authenticationRequestPassword =
  AuthenticationRequest
  { authenticationRequestUsername
  , authenticationRequestPassword
  }

-- ** Error
-- | Error
-- This is returned when the request fails
data Error = Error
  { errorError :: !(Maybe Text) -- ^ "error"
  , errorErrorMessage :: !(Maybe Text) -- ^ "errorMessage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Error
instance A.FromJSON Error where
  parseJSON = A.withObject "Error" $ \o ->
    Error
      <$> (o .:? "error")
      <*> (o .:? "errorMessage")

-- | ToJSON Error
instance A.ToJSON Error where
  toJSON Error {..} =
   _omitNulls
      [ "error" .= errorError
      , "errorMessage" .= errorErrorMessage
      ]


-- | Construct a value of type 'Error' (by applying it's required fields, if any)
mkError
  :: Error
mkError =
  Error
  { errorError = Nothing
  , errorErrorMessage = Nothing
  }

-- ** GameProfile
-- | GameProfile
data GameProfile = GameProfile
  { gameProfileAgent :: !(Maybe Text) -- ^ "agent"
  , gameProfileId :: !(Maybe Text) -- ^ "id"
  , gameProfileName :: !(Maybe Text) -- ^ "name"
  , gameProfileUserId :: !(Maybe Text) -- ^ "userId"
  , gameProfileCreatedAt :: !(Maybe Integer) -- ^ "createdAt" - Unix timestamp in milliseconds
  , gameProfileLegacyProfile :: !(Maybe Bool) -- ^ "legacyProfile"
  , gameProfileSuspended :: !(Maybe Bool) -- ^ "suspended"
  , gameProfilePaid :: !(Maybe Bool) -- ^ "paid"
  , gameProfileMigrated :: !(Maybe Bool) -- ^ "migrated"
  , gameProfileLegacy :: !(Maybe Bool) -- ^ "legacy"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GameProfile
instance A.FromJSON GameProfile where
  parseJSON = A.withObject "GameProfile" $ \o ->
    GameProfile
      <$> (o .:? "agent")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "userId")
      <*> (o .:? "createdAt")
      <*> (o .:? "legacyProfile")
      <*> (o .:? "suspended")
      <*> (o .:? "paid")
      <*> (o .:? "migrated")
      <*> (o .:? "legacy")

-- | ToJSON GameProfile
instance A.ToJSON GameProfile where
  toJSON GameProfile {..} =
   _omitNulls
      [ "agent" .= gameProfileAgent
      , "id" .= gameProfileId
      , "name" .= gameProfileName
      , "userId" .= gameProfileUserId
      , "createdAt" .= gameProfileCreatedAt
      , "legacyProfile" .= gameProfileLegacyProfile
      , "suspended" .= gameProfileSuspended
      , "paid" .= gameProfilePaid
      , "migrated" .= gameProfileMigrated
      , "legacy" .= gameProfileLegacy
      ]


-- | Construct a value of type 'GameProfile' (by applying it's required fields, if any)
mkGameProfile
  :: GameProfile
mkGameProfile =
  GameProfile
  { gameProfileAgent = Nothing
  , gameProfileId = Nothing
  , gameProfileName = Nothing
  , gameProfileUserId = Nothing
  , gameProfileCreatedAt = Nothing
  , gameProfileLegacyProfile = Nothing
  , gameProfileSuspended = Nothing
  , gameProfilePaid = Nothing
  , gameProfileMigrated = Nothing
  , gameProfileLegacy = Nothing
  }

-- ** GameProfileProperty
-- | GameProfileProperty
data GameProfileProperty = GameProfileProperty
  { gameProfilePropertyName :: !(Maybe Text) -- ^ "name"
  , gameProfilePropertyValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GameProfileProperty
instance A.FromJSON GameProfileProperty where
  parseJSON = A.withObject "GameProfileProperty" $ \o ->
    GameProfileProperty
      <$> (o .:? "name")
      <*> (o .:? "value")

-- | ToJSON GameProfileProperty
instance A.ToJSON GameProfileProperty where
  toJSON GameProfileProperty {..} =
   _omitNulls
      [ "name" .= gameProfilePropertyName
      , "value" .= gameProfilePropertyValue
      ]


-- | Construct a value of type 'GameProfileProperty' (by applying it's required fields, if any)
mkGameProfileProperty
  :: GameProfileProperty
mkGameProfileProperty =
  GameProfileProperty
  { gameProfilePropertyName = Nothing
  , gameProfilePropertyValue = Nothing
  }

-- ** PrivateUserData
-- | PrivateUserData
data PrivateUserData = PrivateUserData
  { privateUserDataId :: !(Maybe Text) -- ^ "id"
  , privateUserDataProperties :: !(Maybe [GameProfileProperty]) -- ^ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrivateUserData
instance A.FromJSON PrivateUserData where
  parseJSON = A.withObject "PrivateUserData" $ \o ->
    PrivateUserData
      <$> (o .:? "id")
      <*> (o .:? "properties")

-- | ToJSON PrivateUserData
instance A.ToJSON PrivateUserData where
  toJSON PrivateUserData {..} =
   _omitNulls
      [ "id" .= privateUserDataId
      , "properties" .= privateUserDataProperties
      ]


-- | Construct a value of type 'PrivateUserData' (by applying it's required fields, if any)
mkPrivateUserData
  :: PrivateUserData
mkPrivateUserData =
  PrivateUserData
  { privateUserDataId = Nothing
  , privateUserDataProperties = Nothing
  }

-- ** ProfileId
-- | ProfileId
data ProfileId = ProfileId
  { profileIdId :: !(Text) -- ^ /Required/ "id"
  , profileIdName :: !(Text) -- ^ /Required/ "name" - The player name
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProfileId
instance A.FromJSON ProfileId where
  parseJSON = A.withObject "ProfileId" $ \o ->
    ProfileId
      <$> (o .:  "id")
      <*> (o .:  "name")

-- | ToJSON ProfileId
instance A.ToJSON ProfileId where
  toJSON ProfileId {..} =
   _omitNulls
      [ "id" .= profileIdId
      , "name" .= profileIdName
      ]


-- | Construct a value of type 'ProfileId' (by applying it's required fields, if any)
mkProfileId
  :: Text -- ^ 'profileIdId' 
  -> Text -- ^ 'profileIdName': The player name
  -> ProfileId
mkProfileId profileIdId profileIdName =
  ProfileId
  { profileIdId
  , profileIdName
  }

-- ** ReducedUserData
-- | ReducedUserData
data ReducedUserData = ReducedUserData
  { reducedUserDataId :: !(Maybe Text) -- ^ "id"
  , reducedUserDataProperties :: !(Maybe [GameProfileProperty]) -- ^ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReducedUserData
instance A.FromJSON ReducedUserData where
  parseJSON = A.withObject "ReducedUserData" $ \o ->
    ReducedUserData
      <$> (o .:? "id")
      <*> (o .:? "properties")

-- | ToJSON ReducedUserData
instance A.ToJSON ReducedUserData where
  toJSON ReducedUserData {..} =
   _omitNulls
      [ "id" .= reducedUserDataId
      , "properties" .= reducedUserDataProperties
      ]


-- | Construct a value of type 'ReducedUserData' (by applying it's required fields, if any)
mkReducedUserData
  :: ReducedUserData
mkReducedUserData =
  ReducedUserData
  { reducedUserDataId = Nothing
  , reducedUserDataProperties = Nothing
  }

-- ** RefreshRequest
-- | RefreshRequest
data RefreshRequest = RefreshRequest
  { refreshRequestAccessToken :: !(Text) -- ^ /Required/ "accessToken"
  , refreshRequestClientToken :: !(Maybe Text) -- ^ "clientToken"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RefreshRequest
instance A.FromJSON RefreshRequest where
  parseJSON = A.withObject "RefreshRequest" $ \o ->
    RefreshRequest
      <$> (o .:  "accessToken")
      <*> (o .:? "clientToken")

-- | ToJSON RefreshRequest
instance A.ToJSON RefreshRequest where
  toJSON RefreshRequest {..} =
   _omitNulls
      [ "accessToken" .= refreshRequestAccessToken
      , "clientToken" .= refreshRequestClientToken
      ]


-- | Construct a value of type 'RefreshRequest' (by applying it's required fields, if any)
mkRefreshRequest
  :: Text -- ^ 'refreshRequestAccessToken' 
  -> RefreshRequest
mkRefreshRequest refreshRequestAccessToken =
  RefreshRequest
  { refreshRequestAccessToken
  , refreshRequestClientToken = Nothing
  }

-- ** RefreshResponse
-- | RefreshResponse
data RefreshResponse = RefreshResponse
  { refreshResponseAccessToken :: !(Text) -- ^ /Required/ "accessToken"
  , refreshResponseClientToken :: !(Maybe Text) -- ^ "clientToken"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RefreshResponse
instance A.FromJSON RefreshResponse where
  parseJSON = A.withObject "RefreshResponse" $ \o ->
    RefreshResponse
      <$> (o .:  "accessToken")
      <*> (o .:? "clientToken")

-- | ToJSON RefreshResponse
instance A.ToJSON RefreshResponse where
  toJSON RefreshResponse {..} =
   _omitNulls
      [ "accessToken" .= refreshResponseAccessToken
      , "clientToken" .= refreshResponseClientToken
      ]


-- | Construct a value of type 'RefreshResponse' (by applying it's required fields, if any)
mkRefreshResponse
  :: Text -- ^ 'refreshResponseAccessToken' 
  -> RefreshResponse
mkRefreshResponse refreshResponseAccessToken =
  RefreshResponse
  { refreshResponseAccessToken
  , refreshResponseClientToken = Nothing
  }

-- ** UsernamePassword
-- | UsernamePassword
data UsernamePassword = UsernamePassword
  { usernamePasswordUsername :: !(Text) -- ^ /Required/ "username" - The Mojang account e-mail or username. Never store it.
  , usernamePasswordPassword :: !(Text) -- ^ /Required/ "password" - The Mojang account password, never store it.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UsernamePassword
instance A.FromJSON UsernamePassword where
  parseJSON = A.withObject "UsernamePassword" $ \o ->
    UsernamePassword
      <$> (o .:  "username")
      <*> (o .:  "password")

-- | ToJSON UsernamePassword
instance A.ToJSON UsernamePassword where
  toJSON UsernamePassword {..} =
   _omitNulls
      [ "username" .= usernamePasswordUsername
      , "password" .= usernamePasswordPassword
      ]


-- | Construct a value of type 'UsernamePassword' (by applying it's required fields, if any)
mkUsernamePassword
  :: Text -- ^ 'usernamePasswordUsername': The Mojang account e-mail or username. Never store it.
  -> Text -- ^ 'usernamePasswordPassword': The Mojang account password, never store it.
  -> UsernamePassword
mkUsernamePassword usernamePasswordUsername usernamePasswordPassword =
  UsernamePassword
  { usernamePasswordUsername
  , usernamePasswordPassword
  }


-- * Enums


-- ** E'Name

-- | Enum of 'Text' . 
-- The name of the game
data E'Name
  = E'Name'Minecraft -- ^ @"Minecraft"@
  | E'Name'Scrolls -- ^ @"Scrolls"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Name where toJSON = A.toJSON . fromE'Name
instance A.FromJSON E'Name where parseJSON o = P.either P.fail (pure . P.id) . toE'Name =<< A.parseJSON o
instance WH.ToHttpApiData E'Name where toQueryParam = WH.toQueryParam . fromE'Name
instance WH.FromHttpApiData E'Name where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Name
instance MimeRender MimeMultipartFormData E'Name where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Name' enum
fromE'Name :: E'Name -> Text
fromE'Name = \case
  E'Name'Minecraft -> "Minecraft"
  E'Name'Scrolls -> "Scrolls"

-- | parse 'E'Name' enum
toE'Name :: Text -> P.Either String E'Name
toE'Name = \case
  "Minecraft" -> P.Right E'Name'Minecraft
  "Scrolls" -> P.Right E'Name'Scrolls
  s -> P.Left $ "toE'Name: enum parse failure: " P.++ P.show s


