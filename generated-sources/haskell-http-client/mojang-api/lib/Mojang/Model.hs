{-
   Mojang API

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.1
   Mojang API API version: 2020-06-05
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Mojang.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Mojang.Model where

import Mojang.Core
import Mojang.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** At
newtype At = At { unAt :: Integer } deriving (P.Eq, P.Show)

-- ** File
newtype File = File { unFile :: FilePath } deriving (P.Eq, P.Show)

-- ** RequestBody
newtype RequestBody = RequestBody { unRequestBody :: [Text] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** SecurityAnswer2
newtype SecurityAnswer2 = SecurityAnswer2 { unSecurityAnswer2 :: [SecurityAnswer] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** StrippedUuid
newtype StrippedUuid = StrippedUuid { unStrippedUuid :: Text } deriving (P.Eq, P.Show)

-- ** Url
newtype Url = Url { unUrl :: Text } deriving (P.Eq, P.Show)

-- ** Username
newtype Username = Username { unUsername :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** CurrentPlayerIDs
-- | CurrentPlayerIDs
-- The current player, demo and legacy status of a player identified by the id
data CurrentPlayerIDs = CurrentPlayerIDs
  { currentPlayerIDsId :: !(Text) -- ^ /Required/ "id" - The player UUID without hyphens
  , currentPlayerIDsName :: !(Text) -- ^ /Required/ "name" - The current name being used by this player
  , currentPlayerIDsLegacy :: !(Maybe Bool) -- ^ "legacy" - If account has not been converted
  , currentPlayerIDsDemo :: !(Maybe Bool) -- ^ "demo" - If the player has not puchased the game
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurrentPlayerIDs
instance A.FromJSON CurrentPlayerIDs where
  parseJSON = A.withObject "CurrentPlayerIDs" $ \o ->
    CurrentPlayerIDs
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:? "legacy")
      <*> (o .:? "demo")

-- | ToJSON CurrentPlayerIDs
instance A.ToJSON CurrentPlayerIDs where
  toJSON CurrentPlayerIDs {..} =
   _omitNulls
      [ "id" .= currentPlayerIDsId
      , "name" .= currentPlayerIDsName
      , "legacy" .= currentPlayerIDsLegacy
      , "demo" .= currentPlayerIDsDemo
      ]


-- | Construct a value of type 'CurrentPlayerIDs' (by applying it's required fields, if any)
mkCurrentPlayerIDs
  :: Text -- ^ 'currentPlayerIDsId': The player UUID without hyphens
  -> Text -- ^ 'currentPlayerIDsName': The current name being used by this player
  -> CurrentPlayerIDs
mkCurrentPlayerIDs currentPlayerIDsId currentPlayerIDsName =
  CurrentPlayerIDs
  { currentPlayerIDsId
  , currentPlayerIDsName
  , currentPlayerIDsLegacy = Nothing
  , currentPlayerIDsDemo = Nothing
  }

-- ** Error
-- | Error
-- This is returned when the request fails
data Error = Error
  { errorError :: !(Maybe Text) -- ^ "error"
  , errorErrorMessage :: !(Maybe Text) -- ^ "errorMessage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Error
instance A.FromJSON Error where
  parseJSON = A.withObject "Error" $ \o ->
    Error
      <$> (o .:? "error")
      <*> (o .:? "errorMessage")

-- | ToJSON Error
instance A.ToJSON Error where
  toJSON Error {..} =
   _omitNulls
      [ "error" .= errorError
      , "errorMessage" .= errorErrorMessage
      ]


-- | Construct a value of type 'Error' (by applying it's required fields, if any)
mkError
  :: Error
mkError =
  Error
  { errorError = Nothing
  , errorErrorMessage = Nothing
  }

-- ** InlineObject
-- | InlineObject
data InlineObject = InlineObject
  { inlineObjectModel :: !(Maybe SkinModel) -- ^ "model"
  , inlineObjectFile :: !(FilePath) -- ^ /Required/ "file" - The skin image in PNG format
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject
instance A.FromJSON InlineObject where
  parseJSON = A.withObject "InlineObject" $ \o ->
    InlineObject
      <$> (o .:? "model")
      <*> (o .:  "file")

-- | ToJSON InlineObject
instance A.ToJSON InlineObject where
  toJSON InlineObject {..} =
   _omitNulls
      [ "model" .= inlineObjectModel
      , "file" .= inlineObjectFile
      ]


-- | Construct a value of type 'InlineObject' (by applying it's required fields, if any)
mkInlineObject
  :: FilePath -- ^ 'inlineObjectFile': The skin image in PNG format
  -> InlineObject
mkInlineObject inlineObjectFile =
  InlineObject
  { inlineObjectModel = Nothing
  , inlineObjectFile
  }

-- ** InlineObject1
-- | InlineObject1
-- Request Mojang to download a skin from an URL and apply to the player
data InlineObject1 = InlineObject1
  { inlineObject1Model :: !(Maybe SkinModel) -- ^ "model"
  , inlineObject1Url :: !(Text) -- ^ /Required/ "url" - The URL which Mojang servers will download and apply the skin
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject1
instance A.FromJSON InlineObject1 where
  parseJSON = A.withObject "InlineObject1" $ \o ->
    InlineObject1
      <$> (o .:? "model")
      <*> (o .:  "url")

-- | ToJSON InlineObject1
instance A.ToJSON InlineObject1 where
  toJSON InlineObject1 {..} =
   _omitNulls
      [ "model" .= inlineObject1Model
      , "url" .= inlineObject1Url
      ]


-- | Construct a value of type 'InlineObject1' (by applying it's required fields, if any)
mkInlineObject1
  :: Text -- ^ 'inlineObject1Url': The URL which Mojang servers will download and apply the skin
  -> InlineObject1
mkInlineObject1 inlineObject1Url =
  InlineObject1
  { inlineObject1Model = Nothing
  , inlineObject1Url
  }

-- ** NameChange
-- | NameChange
-- A registered name change.
data NameChange = NameChange
  { nameChangeName :: !(Text) -- ^ /Required/ "name" - The new player name
  , nameChangeChangedToAt :: !(Maybe Integer) -- ^ "changedToAt" - Time which the name was changed in UNIX Timestamp without milliseconds. Usually absent for the first entry.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NameChange
instance A.FromJSON NameChange where
  parseJSON = A.withObject "NameChange" $ \o ->
    NameChange
      <$> (o .:  "name")
      <*> (o .:? "changedToAt")

-- | ToJSON NameChange
instance A.ToJSON NameChange where
  toJSON NameChange {..} =
   _omitNulls
      [ "name" .= nameChangeName
      , "changedToAt" .= nameChangeChangedToAt
      ]


-- | Construct a value of type 'NameChange' (by applying it's required fields, if any)
mkNameChange
  :: Text -- ^ 'nameChangeName': The new player name
  -> NameChange
mkNameChange nameChangeName =
  NameChange
  { nameChangeName
  , nameChangeChangedToAt = Nothing
  }

-- ** OrderStatisticsRequest
-- | OrderStatisticsRequest
-- The body of the request to get the order statistics
data OrderStatisticsRequest = OrderStatisticsRequest
  { orderStatisticsRequestMetricKeys :: !([OrderStatistic]) -- ^ /Required/ "metricKeys"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderStatisticsRequest
instance A.FromJSON OrderStatisticsRequest where
  parseJSON = A.withObject "OrderStatisticsRequest" $ \o ->
    OrderStatisticsRequest
      <$> (o .:  "metricKeys")

-- | ToJSON OrderStatisticsRequest
instance A.ToJSON OrderStatisticsRequest where
  toJSON OrderStatisticsRequest {..} =
   _omitNulls
      [ "metricKeys" .= orderStatisticsRequestMetricKeys
      ]


-- | Construct a value of type 'OrderStatisticsRequest' (by applying it's required fields, if any)
mkOrderStatisticsRequest
  :: [OrderStatistic] -- ^ 'orderStatisticsRequestMetricKeys' 
  -> OrderStatisticsRequest
mkOrderStatisticsRequest orderStatisticsRequestMetricKeys =
  OrderStatisticsRequest
  { orderStatisticsRequestMetricKeys
  }

-- ** OrderStatisticsResponse
-- | OrderStatisticsResponse
-- A json object is returned with the total amount of copies sold, the amount of copies sold in the last 24h and how many sales there are per second.
data OrderStatisticsResponse = OrderStatisticsResponse
  { orderStatisticsResponseTotal :: !(Integer) -- ^ /Required/ "total" - total amount sold
  , orderStatisticsResponseLast24h :: !(Integer) -- ^ /Required/ "last24h" - total sold in last 24 hours
  , orderStatisticsResponseSaleVelocityPerSeconds :: !(Double) -- ^ /Required/ "saleVelocityPerSeconds" - decimal average sales per second
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderStatisticsResponse
instance A.FromJSON OrderStatisticsResponse where
  parseJSON = A.withObject "OrderStatisticsResponse" $ \o ->
    OrderStatisticsResponse
      <$> (o .:  "total")
      <*> (o .:  "last24h")
      <*> (o .:  "saleVelocityPerSeconds")

-- | ToJSON OrderStatisticsResponse
instance A.ToJSON OrderStatisticsResponse where
  toJSON OrderStatisticsResponse {..} =
   _omitNulls
      [ "total" .= orderStatisticsResponseTotal
      , "last24h" .= orderStatisticsResponseLast24h
      , "saleVelocityPerSeconds" .= orderStatisticsResponseSaleVelocityPerSeconds
      ]


-- | Construct a value of type 'OrderStatisticsResponse' (by applying it's required fields, if any)
mkOrderStatisticsResponse
  :: Integer -- ^ 'orderStatisticsResponseTotal': total amount sold
  -> Integer -- ^ 'orderStatisticsResponseLast24h': total sold in last 24 hours
  -> Double -- ^ 'orderStatisticsResponseSaleVelocityPerSeconds': decimal average sales per second
  -> OrderStatisticsResponse
mkOrderStatisticsResponse orderStatisticsResponseTotal orderStatisticsResponseLast24h orderStatisticsResponseSaleVelocityPerSeconds =
  OrderStatisticsResponse
  { orderStatisticsResponseTotal
  , orderStatisticsResponseLast24h
  , orderStatisticsResponseSaleVelocityPerSeconds
  }

-- ** SecurityAnswer
-- | SecurityAnswer
-- A security question answer given by the player using the id given by Mojang
data SecurityAnswer = SecurityAnswer
  { securityAnswerId :: !(Int) -- ^ /Required/ "id" - A number giver by Mojang to reply a question
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurityAnswer
instance A.FromJSON SecurityAnswer where
  parseJSON = A.withObject "SecurityAnswer" $ \o ->
    SecurityAnswer
      <$> (o .:  "id")

-- | ToJSON SecurityAnswer
instance A.ToJSON SecurityAnswer where
  toJSON SecurityAnswer {..} =
   _omitNulls
      [ "id" .= securityAnswerId
      ]


-- | Construct a value of type 'SecurityAnswer' (by applying it's required fields, if any)
mkSecurityAnswer
  :: Int -- ^ 'securityAnswerId': A number giver by Mojang to reply a question
  -> SecurityAnswer
mkSecurityAnswer securityAnswerId =
  SecurityAnswer
  { securityAnswerId
  }

-- ** SecurityAnswerId
-- | SecurityAnswerId
-- A security question answer id given by Mojang
data SecurityAnswerId = SecurityAnswerId
  { securityAnswerIdId :: !(Int) -- ^ /Required/ "id" - A number giver by Mojang to reply a question
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurityAnswerId
instance A.FromJSON SecurityAnswerId where
  parseJSON = A.withObject "SecurityAnswerId" $ \o ->
    SecurityAnswerId
      <$> (o .:  "id")

-- | ToJSON SecurityAnswerId
instance A.ToJSON SecurityAnswerId where
  toJSON SecurityAnswerId {..} =
   _omitNulls
      [ "id" .= securityAnswerIdId
      ]


-- | Construct a value of type 'SecurityAnswerId' (by applying it's required fields, if any)
mkSecurityAnswerId
  :: Int -- ^ 'securityAnswerIdId': A number giver by Mojang to reply a question
  -> SecurityAnswerId
mkSecurityAnswerId securityAnswerIdId =
  SecurityAnswerId
  { securityAnswerIdId
  }

-- ** SecurityChallenge
-- | SecurityChallenge
-- Binds a question to an answer id, the answer must respect the answer id.
data SecurityChallenge = SecurityChallenge
  { securityChallengeQuestion :: !(SecurityQuestion) -- ^ /Required/ "question"
  , securityChallengeAnswer :: !(SecurityAnswerId) -- ^ /Required/ "answer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurityChallenge
instance A.FromJSON SecurityChallenge where
  parseJSON = A.withObject "SecurityChallenge" $ \o ->
    SecurityChallenge
      <$> (o .:  "question")
      <*> (o .:  "answer")

-- | ToJSON SecurityChallenge
instance A.ToJSON SecurityChallenge where
  toJSON SecurityChallenge {..} =
   _omitNulls
      [ "question" .= securityChallengeQuestion
      , "answer" .= securityChallengeAnswer
      ]


-- | Construct a value of type 'SecurityChallenge' (by applying it's required fields, if any)
mkSecurityChallenge
  :: SecurityQuestion -- ^ 'securityChallengeQuestion' 
  -> SecurityAnswerId -- ^ 'securityChallengeAnswer' 
  -> SecurityChallenge
mkSecurityChallenge securityChallengeQuestion securityChallengeAnswer =
  SecurityChallenge
  { securityChallengeQuestion
  , securityChallengeAnswer
  }

-- ** SecurityQuestion
-- | SecurityQuestion
-- A security question requested by Mojang
data SecurityQuestion = SecurityQuestion
  { securityQuestionId :: !(Int) -- ^ /Required/ "id" - The possible IDs are these:   1  What is your favorite pet&#39;s name?   2  What is your favorite movie?   3  What is your favorite author&#39;s last name?   4  What is your favorite artist&#39;s last name?   5  What is your favorite actor&#39;s last name?   6  What is your favorite activity?   7  What is your favorite restaurant?   8  What is the name of your favorite cartoon?   9  What is the name of the first school you attended?   10 What is the last name of your favorite teacher?   11 What is your best friend&#39;s first name?   12 What is your favorite cousin&#39;s name?   13 What was the first name of your first girl/boyfriend?   14 What was the name of your first stuffed animal?   15 What is your mother&#39;s middle name?   16 What is your father&#39;s middle name?   17 What is your oldest sibling&#39;s middle name?   18 In what city did your parents meet?   19 In what hospital were you born?   20 What is your favorite team?   21 How old were you when you got your first computer?   22 How old were you when you got your first gaming console?   23 What was your first video game?   24 What is your favorite card game?   25 What is your favorite board game?   26 What was your first gaming console?   27 What was the first book you ever read?   28 Where did you go on your first holiday?   29 In what city does your grandmother live?   30 In what city does your grandfather live?   31 What is your grandmother&#39;s first name?   32 What is your grandfather&#39;s first name?   33 What is your least favorite food?   34 What is your favorite ice cream flavor?   35 What is your favorite ice cream flavor?   36 What is your favorite place to visit?   37 What is your dream job?   38 What color was your first pet?   39 What is your lucky number?
  , securityQuestionQuestion :: !(Text) -- ^ /Required/ "question" - The question itself
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurityQuestion
instance A.FromJSON SecurityQuestion where
  parseJSON = A.withObject "SecurityQuestion" $ \o ->
    SecurityQuestion
      <$> (o .:  "id")
      <*> (o .:  "question")

-- | ToJSON SecurityQuestion
instance A.ToJSON SecurityQuestion where
  toJSON SecurityQuestion {..} =
   _omitNulls
      [ "id" .= securityQuestionId
      , "question" .= securityQuestionQuestion
      ]


-- | Construct a value of type 'SecurityQuestion' (by applying it's required fields, if any)
mkSecurityQuestion
  :: Int -- ^ 'securityQuestionId': The possible IDs are these:   1  What is your favorite pet's name?   2  What is your favorite movie?   3  What is your favorite author's last name?   4  What is your favorite artist's last name?   5  What is your favorite actor's last name?   6  What is your favorite activity?   7  What is your favorite restaurant?   8  What is the name of your favorite cartoon?   9  What is the name of the first school you attended?   10 What is the last name of your favorite teacher?   11 What is your best friend's first name?   12 What is your favorite cousin's name?   13 What was the first name of your first girl/boyfriend?   14 What was the name of your first stuffed animal?   15 What is your mother's middle name?   16 What is your father's middle name?   17 What is your oldest sibling's middle name?   18 In what city did your parents meet?   19 In what hospital were you born?   20 What is your favorite team?   21 How old were you when you got your first computer?   22 How old were you when you got your first gaming console?   23 What was your first video game?   24 What is your favorite card game?   25 What is your favorite board game?   26 What was your first gaming console?   27 What was the first book you ever read?   28 Where did you go on your first holiday?   29 In what city does your grandmother live?   30 In what city does your grandfather live?   31 What is your grandmother's first name?   32 What is your grandfather's first name?   33 What is your least favorite food?   34 What is your favorite ice cream flavor?   35 What is your favorite ice cream flavor?   36 What is your favorite place to visit?   37 What is your dream job?   38 What color was your first pet?   39 What is your lucky number?
  -> Text -- ^ 'securityQuestionQuestion': The question itself
  -> SecurityQuestion
mkSecurityQuestion securityQuestionId securityQuestionQuestion =
  SecurityQuestion
  { securityQuestionId
  , securityQuestionQuestion
  }


-- * Enums


-- ** OrderStatistic

-- | Enum of 'Text' . 
-- Valid options to query the order statistics
data OrderStatistic
  = OrderStatistic'Item_sold_minecraft -- ^ @"item_sold_minecraft"@
  | OrderStatistic'Prepaid_card_redeemed_minecraft -- ^ @"prepaid_card_redeemed_minecraft"@
  | OrderStatistic'Item_sold_cobalt -- ^ @"item_sold_cobalt"@
  | OrderStatistic'Item_sold_scrolls -- ^ @"item_sold_scrolls"@
  | OrderStatistic'Prepaid_card_redeemed_cobalt -- ^ @"prepaid_card_redeemed_cobalt"@
  | OrderStatistic'Item_sold_dungeons -- ^ @"item_sold_dungeons"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderStatistic where toJSON = A.toJSON . fromOrderStatistic
instance A.FromJSON OrderStatistic where parseJSON o = P.either P.fail (pure . P.id) . toOrderStatistic =<< A.parseJSON o
instance WH.ToHttpApiData OrderStatistic where toQueryParam = WH.toQueryParam . fromOrderStatistic
instance WH.FromHttpApiData OrderStatistic where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderStatistic
instance MimeRender MimeMultipartFormData OrderStatistic where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderStatistic' enum
fromOrderStatistic :: OrderStatistic -> Text
fromOrderStatistic = \case
  OrderStatistic'Item_sold_minecraft -> "item_sold_minecraft"
  OrderStatistic'Prepaid_card_redeemed_minecraft -> "prepaid_card_redeemed_minecraft"
  OrderStatistic'Item_sold_cobalt -> "item_sold_cobalt"
  OrderStatistic'Item_sold_scrolls -> "item_sold_scrolls"
  OrderStatistic'Prepaid_card_redeemed_cobalt -> "prepaid_card_redeemed_cobalt"
  OrderStatistic'Item_sold_dungeons -> "item_sold_dungeons"

-- | parse 'OrderStatistic' enum
toOrderStatistic :: Text -> P.Either String OrderStatistic
toOrderStatistic = \case
  "item_sold_minecraft" -> P.Right OrderStatistic'Item_sold_minecraft
  "prepaid_card_redeemed_minecraft" -> P.Right OrderStatistic'Prepaid_card_redeemed_minecraft
  "item_sold_cobalt" -> P.Right OrderStatistic'Item_sold_cobalt
  "item_sold_scrolls" -> P.Right OrderStatistic'Item_sold_scrolls
  "prepaid_card_redeemed_cobalt" -> P.Right OrderStatistic'Prepaid_card_redeemed_cobalt
  "item_sold_dungeons" -> P.Right OrderStatistic'Item_sold_dungeons
  s -> P.Left $ "toOrderStatistic: enum parse failure: " P.++ P.show s


-- ** SkinModel

-- | Enum of 'Text' . 
-- Model is an empty string for the default model (like Steve) and \"slim\" for the slim model (like Alex)
data SkinModel
  = SkinModel'Empty -- ^ @""@
  | SkinModel'Slim -- ^ @"slim"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SkinModel where toJSON = A.toJSON . fromSkinModel
instance A.FromJSON SkinModel where parseJSON o = P.either P.fail (pure . P.id) . toSkinModel =<< A.parseJSON o
instance WH.ToHttpApiData SkinModel where toQueryParam = WH.toQueryParam . fromSkinModel
instance WH.FromHttpApiData SkinModel where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSkinModel
instance MimeRender MimeMultipartFormData SkinModel where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SkinModel' enum
fromSkinModel :: SkinModel -> Text
fromSkinModel = \case
  SkinModel'Empty -> ""
  SkinModel'Slim -> "slim"

-- | parse 'SkinModel' enum
toSkinModel :: Text -> P.Either String SkinModel
toSkinModel = \case
  "" -> P.Right SkinModel'Empty
  "slim" -> P.Right SkinModel'Slim
  s -> P.Left $ "toSkinModel: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthBasicMojangStatisticsToken
data AuthBasicMojangStatisticsToken =
  AuthBasicMojangStatisticsToken B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicMojangStatisticsToken where
  applyAuthMethod _ a@(AuthBasicMojangStatisticsToken user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])

-- ** AuthBasicPlayerAccessToken
data AuthBasicPlayerAccessToken =
  AuthBasicPlayerAccessToken B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicPlayerAccessToken where
  applyAuthMethod _ a@(AuthBasicPlayerAccessToken user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])

