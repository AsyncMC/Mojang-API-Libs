{-
   Mojang Session API

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.1
   Mojang Session API API version: 2020-06-05
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : MojangSession.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module MojangSession.Model where

import MojangSession.Core
import MojangSession.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** StrippedUuid
newtype StrippedUuid = StrippedUuid { unStrippedUuid :: Text } deriving (P.Eq, P.Show)

-- ** Unsigned
newtype Unsigned = Unsigned { unUnsigned :: Bool } deriving (P.Eq, P.Show)

-- * Models


-- ** PlayerProfile
-- | PlayerProfile
data PlayerProfile = PlayerProfile
  { playerProfileId :: !(Text) -- ^ /Required/ "id" - The player UUID without hyphens
  , playerProfileName :: !(Text) -- ^ /Required/ "name"
  , playerProfileLegacy :: !(Maybe Bool) -- ^ "legacy" - Will appear in the response if the user has not migrated their minecraft.net account to Mojang.
  , playerProfileProperties :: !([PlayerProfileProperty]) -- ^ /Required/ "properties" - An array with all player properties, like skin and cape
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PlayerProfile
instance A.FromJSON PlayerProfile where
  parseJSON = A.withObject "PlayerProfile" $ \o ->
    PlayerProfile
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:? "legacy")
      <*> (o .:  "properties")

-- | ToJSON PlayerProfile
instance A.ToJSON PlayerProfile where
  toJSON PlayerProfile {..} =
   _omitNulls
      [ "id" .= playerProfileId
      , "name" .= playerProfileName
      , "legacy" .= playerProfileLegacy
      , "properties" .= playerProfileProperties
      ]


-- | Construct a value of type 'PlayerProfile' (by applying it's required fields, if any)
mkPlayerProfile
  :: Text -- ^ 'playerProfileId': The player UUID without hyphens
  -> Text -- ^ 'playerProfileName' 
  -> [PlayerProfileProperty] -- ^ 'playerProfileProperties': An array with all player properties, like skin and cape
  -> PlayerProfile
mkPlayerProfile playerProfileId playerProfileName playerProfileProperties =
  PlayerProfile
  { playerProfileId
  , playerProfileName
  , playerProfileLegacy = Nothing
  , playerProfileProperties
  }

-- ** PlayerProfileProperty
-- | PlayerProfileProperty
-- A profile property, may be signed. The values are encoded by base64 and usually contains a json. The schema for the textures are described at PlayerProfileTexturePropertyValue
data PlayerProfileProperty = PlayerProfileProperty
  { playerProfilePropertyName :: !(Text) -- ^ /Required/ "name" - The property name
  , playerProfilePropertyValue :: !(ByteArray) -- ^ /Required/ "value" - The serialized property value in base64.
  , playerProfilePropertySignature :: !(Maybe ByteArray) -- ^ "signature" - signed data using Yggdrasil&#39;s private key
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PlayerProfileProperty
instance A.FromJSON PlayerProfileProperty where
  parseJSON = A.withObject "PlayerProfileProperty" $ \o ->
    PlayerProfileProperty
      <$> (o .:  "name")
      <*> (o .:  "value")
      <*> (o .:? "signature")

-- | ToJSON PlayerProfileProperty
instance A.ToJSON PlayerProfileProperty where
  toJSON PlayerProfileProperty {..} =
   _omitNulls
      [ "name" .= playerProfilePropertyName
      , "value" .= playerProfilePropertyValue
      , "signature" .= playerProfilePropertySignature
      ]


-- | Construct a value of type 'PlayerProfileProperty' (by applying it's required fields, if any)
mkPlayerProfileProperty
  :: Text -- ^ 'playerProfilePropertyName': The property name
  -> ByteArray -- ^ 'playerProfilePropertyValue': The serialized property value in base64.
  -> PlayerProfileProperty
mkPlayerProfileProperty playerProfilePropertyName playerProfilePropertyValue =
  PlayerProfileProperty
  { playerProfilePropertyName
  , playerProfilePropertyValue
  , playerProfilePropertySignature = Nothing
  }

-- ** PlayerProfileTexturePropertyValue
-- | PlayerProfileTexturePropertyValue
-- This is obtained by decoding the \"textures\" property
data PlayerProfileTexturePropertyValue = PlayerProfileTexturePropertyValue
  { playerProfileTexturePropertyValueTimestamp :: !(Integer) -- ^ /Required/ "timestamp" - UNIX timestamp in milliseconds
  , playerProfileTexturePropertyValueProfileId :: !(Text) -- ^ /Required/ "profileId" - The player UUID without hyphens
  , playerProfileTexturePropertyValueProfileName :: !(Text) -- ^ /Required/ "profileName" - The player&#39;s name
  , playerProfileTexturePropertyValueSignatureRequired :: !(Maybe Bool) -- ^ "signatureRequired" - Only present if unsigned was set to false in the request
  , playerProfileTexturePropertyValueTextures :: !(Maybe PlayerTexture) -- ^ "textures"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PlayerProfileTexturePropertyValue
instance A.FromJSON PlayerProfileTexturePropertyValue where
  parseJSON = A.withObject "PlayerProfileTexturePropertyValue" $ \o ->
    PlayerProfileTexturePropertyValue
      <$> (o .:  "timestamp")
      <*> (o .:  "profileId")
      <*> (o .:  "profileName")
      <*> (o .:? "signatureRequired")
      <*> (o .:? "textures")

-- | ToJSON PlayerProfileTexturePropertyValue
instance A.ToJSON PlayerProfileTexturePropertyValue where
  toJSON PlayerProfileTexturePropertyValue {..} =
   _omitNulls
      [ "timestamp" .= playerProfileTexturePropertyValueTimestamp
      , "profileId" .= playerProfileTexturePropertyValueProfileId
      , "profileName" .= playerProfileTexturePropertyValueProfileName
      , "signatureRequired" .= playerProfileTexturePropertyValueSignatureRequired
      , "textures" .= playerProfileTexturePropertyValueTextures
      ]


-- | Construct a value of type 'PlayerProfileTexturePropertyValue' (by applying it's required fields, if any)
mkPlayerProfileTexturePropertyValue
  :: Integer -- ^ 'playerProfileTexturePropertyValueTimestamp': UNIX timestamp in milliseconds
  -> Text -- ^ 'playerProfileTexturePropertyValueProfileId': The player UUID without hyphens
  -> Text -- ^ 'playerProfileTexturePropertyValueProfileName': The player's name
  -> PlayerProfileTexturePropertyValue
mkPlayerProfileTexturePropertyValue playerProfileTexturePropertyValueTimestamp playerProfileTexturePropertyValueProfileId playerProfileTexturePropertyValueProfileName =
  PlayerProfileTexturePropertyValue
  { playerProfileTexturePropertyValueTimestamp
  , playerProfileTexturePropertyValueProfileId
  , playerProfileTexturePropertyValueProfileName
  , playerProfileTexturePropertyValueSignatureRequired = Nothing
  , playerProfileTexturePropertyValueTextures = Nothing
  }

-- ** PlayerSkinMetadata
-- | PlayerSkinMetadata
-- Contains details about the skin
data PlayerSkinMetadata = PlayerSkinMetadata
  { playerSkinMetadataModel :: !(Maybe E'Model) -- ^ "model" - The player model, currently only \&quot;slim\&quot; (Alex) is valid, for Steve&#39;s model this property must be absent.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PlayerSkinMetadata
instance A.FromJSON PlayerSkinMetadata where
  parseJSON = A.withObject "PlayerSkinMetadata" $ \o ->
    PlayerSkinMetadata
      <$> (o .:? "model")

-- | ToJSON PlayerSkinMetadata
instance A.ToJSON PlayerSkinMetadata where
  toJSON PlayerSkinMetadata {..} =
   _omitNulls
      [ "model" .= playerSkinMetadataModel
      ]


-- | Construct a value of type 'PlayerSkinMetadata' (by applying it's required fields, if any)
mkPlayerSkinMetadata
  :: PlayerSkinMetadata
mkPlayerSkinMetadata =
  PlayerSkinMetadata
  { playerSkinMetadataModel = Nothing
  }

-- ** PlayerSkinURL
-- | PlayerSkinURL
-- Wraps the URL to the texture and configures the player's model
data PlayerSkinURL = PlayerSkinURL
  { playerSkinURLUrl :: !(Text) -- ^ /Required/ "url" - The URL to the texture, must be in Mojang&#39;s domains.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PlayerSkinURL
instance A.FromJSON PlayerSkinURL where
  parseJSON = A.withObject "PlayerSkinURL" $ \o ->
    PlayerSkinURL
      <$> (o .:  "url")

-- | ToJSON PlayerSkinURL
instance A.ToJSON PlayerSkinURL where
  toJSON PlayerSkinURL {..} =
   _omitNulls
      [ "url" .= playerSkinURLUrl
      ]


-- | Construct a value of type 'PlayerSkinURL' (by applying it's required fields, if any)
mkPlayerSkinURL
  :: Text -- ^ 'playerSkinURLUrl': The URL to the texture, must be in Mojang's domains.
  -> PlayerSkinURL
mkPlayerSkinURL playerSkinURLUrl =
  PlayerSkinURL
  { playerSkinURLUrl
  }

-- ** PlayerTexture
-- | PlayerTexture
-- Provide links to the player's skin and cape
data PlayerTexture = PlayerTexture
  { playerTextureSkin :: !(Maybe PlayerSkinURL) -- ^ "SKIN"
  , playerTextureCape :: !(Maybe PlayerTextureURL) -- ^ "CAPE"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PlayerTexture
instance A.FromJSON PlayerTexture where
  parseJSON = A.withObject "PlayerTexture" $ \o ->
    PlayerTexture
      <$> (o .:? "SKIN")
      <*> (o .:? "CAPE")

-- | ToJSON PlayerTexture
instance A.ToJSON PlayerTexture where
  toJSON PlayerTexture {..} =
   _omitNulls
      [ "SKIN" .= playerTextureSkin
      , "CAPE" .= playerTextureCape
      ]


-- | Construct a value of type 'PlayerTexture' (by applying it's required fields, if any)
mkPlayerTexture
  :: PlayerTexture
mkPlayerTexture =
  PlayerTexture
  { playerTextureSkin = Nothing
  , playerTextureCape = Nothing
  }

-- ** PlayerTextureURL
-- | PlayerTextureURL
-- Wraps the URL to the texture
data PlayerTextureURL = PlayerTextureURL
  { playerTextureURLUrl :: !(Text) -- ^ /Required/ "url" - The URL to the texture, must be in Mojang&#39;s domains.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PlayerTextureURL
instance A.FromJSON PlayerTextureURL where
  parseJSON = A.withObject "PlayerTextureURL" $ \o ->
    PlayerTextureURL
      <$> (o .:  "url")

-- | ToJSON PlayerTextureURL
instance A.ToJSON PlayerTextureURL where
  toJSON PlayerTextureURL {..} =
   _omitNulls
      [ "url" .= playerTextureURLUrl
      ]


-- | Construct a value of type 'PlayerTextureURL' (by applying it's required fields, if any)
mkPlayerTextureURL
  :: Text -- ^ 'playerTextureURLUrl': The URL to the texture, must be in Mojang's domains.
  -> PlayerTextureURL
mkPlayerTextureURL playerTextureURLUrl =
  PlayerTextureURL
  { playerTextureURLUrl
  }

-- ** SessionApiError
-- | SessionApiError
-- An object describing giving a bit of information about the error
data SessionApiError = SessionApiError
  { sessionApiErrorError :: !(Maybe Text) -- ^ "error" - A message describing the error
  , sessionApiErrorPath :: !(Maybe Text) -- ^ "path" - The request path
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SessionApiError
instance A.FromJSON SessionApiError where
  parseJSON = A.withObject "SessionApiError" $ \o ->
    SessionApiError
      <$> (o .:? "error")
      <*> (o .:? "path")

-- | ToJSON SessionApiError
instance A.ToJSON SessionApiError where
  toJSON SessionApiError {..} =
   _omitNulls
      [ "error" .= sessionApiErrorError
      , "path" .= sessionApiErrorPath
      ]


-- | Construct a value of type 'SessionApiError' (by applying it's required fields, if any)
mkSessionApiError
  :: SessionApiError
mkSessionApiError =
  SessionApiError
  { sessionApiErrorError = Nothing
  , sessionApiErrorPath = Nothing
  }


-- * Enums


-- ** E'Model

-- | Enum of 'Text' . 
-- The player model, currently only \"slim\" (Alex) is valid, for Steve's model this property must be absent.
data E'Model
  = E'Model'Slim -- ^ @"slim"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model where toJSON = A.toJSON . fromE'Model
instance A.FromJSON E'Model where parseJSON o = P.either P.fail (pure . P.id) . toE'Model =<< A.parseJSON o
instance WH.ToHttpApiData E'Model where toQueryParam = WH.toQueryParam . fromE'Model
instance WH.FromHttpApiData E'Model where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model
instance MimeRender MimeMultipartFormData E'Model where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model' enum
fromE'Model :: E'Model -> Text
fromE'Model = \case
  E'Model'Slim -> "slim"

-- | parse 'E'Model' enum
toE'Model :: Text -> P.Either String E'Model
toE'Model = \case
  "slim" -> P.Right E'Model'Slim
  s -> P.Left $ "toE'Model: enum parse failure: " P.++ P.show s


